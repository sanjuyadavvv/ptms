"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.checkRequiredKeys = exports.isLocaleValid = exports.extractLanguageTag = exports.readNestedProperty = exports.replaceAllMatch = exports.removeAllWhiteSpaces = exports.assignNestedProperty = exports.forceNumber = exports.isQueryParamFilled = exports.isFilled = void 0;
/**
 * Get if the given value is null or undefined
 * @param value input
 */
function isFilled(value) {
    return value !== null && value !== undefined;
}
exports.isFilled = isFilled;
;
/**
 * Get if the given value is not null or not undefined and length > 0
 * @param value input
 */
function isQueryParamFilled(value) {
    return value !== null && value !== undefined && `${value}`.length !== 0;
}
exports.isQueryParamFilled = isQueryParamFilled;
;
/**
 * Return 0 if the number in NaN and the number if not
 * @param value number
 */
const forceNumber = (value) => {
    const num = Number(value);
    return isNaN(num) ? 0 : num;
};
exports.forceNumber = forceNumber;
/**
 * Assign nested property in object
 *
 * @deprecated use Obj.assignNestedProperty instead
 *
 * @param obj object
 * @param keyPath key path list
 * @param value value to assign
 */
const assignNestedProperty = (obj, keyPath, value) => {
    for (let index = 0; index < keyPath.length; index++) {
        const key = keyPath[index];
        if (index != keyPath.length - 1) {
            if (!(key in obj)) {
                obj[key] = {};
            }
            obj = obj[key];
        }
        else {
            obj[key] = value;
        }
    }
};
exports.assignNestedProperty = assignNestedProperty;
/**
 * Remove all white spaces in string
 * @param value string
 * @param replacement string that will replace the space
 */
const removeAllWhiteSpaces = (value, replacement) => {
    return value.replace(/\s/g, replacement || "");
};
exports.removeAllWhiteSpaces = removeAllWhiteSpaces;
/**
 * Replace all occurences of a searched string in another string
 *
 * @param value target string
 * @param search element to replace
 * @param replacement replacement
 */
const replaceAllMatch = (value, search, replacement) => {
    return value.replace(search, replacement);
};
exports.replaceAllMatch = replaceAllMatch;
/**
 * Return a value of a nested property (last key in the given path)
 *
 * @deprecated use Obj.readNestedProperty instead
 *
 * @param obj object
 * @param keyPath key path list
 */
const readNestedProperty = (obj, keyPath) => {
    for (let index = 0; index < keyPath.length; index++) {
        const key = keyPath[index];
        if (index != keyPath.length - 1) {
            if (!(key in obj)) {
                return undefined;
            }
            obj = obj[key];
        }
        else {
            return obj[key];
        }
    }
    return undefined;
};
exports.readNestedProperty = readNestedProperty;
/**
 * Extract language tag
 * @param value language string
 */
const extractLanguageTag = (value) => {
    if (value) {
        if (value.indexOf("-") != -1) {
            return value === null || value === void 0 ? void 0 : value.split("-")[0];
        }
        else if (value.indexOf("_") != -1) {
            return value === null || value === void 0 ? void 0 : value.split("_")[0];
        }
        else {
            return "";
        }
    }
    else {
        return "";
    }
};
exports.extractLanguageTag = extractLanguageTag;
/**
 * Check if the locale string is valid
 * @param locale locale
 */
const isLocaleValid = (locale) => {
    if (locale !== null && locale !== undefined && locale.length != 0) {
        let parts = locale.split(/[_-]/);
        if (parts.length != 2) {
            return false;
        }
        else {
            for (let index = 0; index < parts.length; index++) {
                const tag = parts[index];
                if (tag.length != 2) {
                    return false;
                }
            }
            return true;
        }
    }
    else {
        return false;
    }
};
exports.isLocaleValid = isLocaleValid;
/**
 * Check required keys
 * @param attrs object attributes
 * @param target object
 * @deprecated use Obj.missingKeys instead
 */
function checkRequiredKeys(attrs, target) {
    const r = [];
    for (const attr of attrs) {
        const element = target[attr];
        if (!element || (typeof element === "string" && element.length === 0)) {
            r.push(attr);
        }
    }
    return r;
}
exports.checkRequiredKeys = checkRequiredKeys;
