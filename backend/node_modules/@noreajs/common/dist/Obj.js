"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function firstValueOrNull(...args) {
    let nullFound = false;
    for (const item of args) {
        if (typeof item !== "undefined" && item !== null) {
            return item;
        }
        else {
            if (item === null) {
                nullFound = true;
            }
        }
    }
    if (nullFound) {
        return null;
    }
    else {
        return undefined;
    }
}
class Obj {
    /**
     * Assign nested property in object
     *
     * @param obj object
     * @param keyPath key path list
     * @param value value to assign
     */
    static assignNestedProperty(obj, keyPath, value) {
        for (let index = 0; index < keyPath.length; index++) {
            const key = keyPath[index];
            if (index != keyPath.length - 1) {
                if (!(key in obj)) {
                    obj[key] = {};
                }
                obj = obj[key];
            }
            else {
                obj[key] = value;
            }
        }
    }
    /**
     * Return a value of a nested property (last key in the given path)
     * @param obj object
     * @param keyPath key path list
     */
    static readNestedProperty(obj, keyPath) {
        for (let index = 0; index < keyPath.length; index++) {
            const key = keyPath[index];
            if (index != keyPath.length - 1) {
                if (!(key in obj)) {
                    return undefined;
                }
                obj = obj[key];
            }
            else {
                return obj[key];
            }
        }
        return undefined;
    }
    /**
     * Returns keys in the given array missing in the targeted object.
     * @param keys keys
     * @param target object
     */
    static missingKeys(keys, target) {
        const r = [];
        for (const attr of keys) {
            const element = target[attr];
            if (element === null ||
                element === undefined ||
                (typeof element === "string" && element.length === 0)) {
                r.push(attr);
            }
        }
        return r;
    }
    /**
     * Extracting a list of property values.
     * @param obj object
     * @param key key
     */
    static pluck(array, key) {
        const r = [];
        for (const obj of array) {
            for (const keyItem in obj) {
                if (keyItem === key) {
                    const element = obj[keyItem];
                    r.push(element);
                }
            }
        }
        return r;
    }
    /**
     * Extracting a list of nested property values.
     * @param obj object
     * @param key key
     */
    static pluckNested(array, keyPath) {
        const r = [];
        for (const obj of array) {
            const path = typeof keyPath === "string" ? keyPath.split(".") : keyPath;
            r.push(Obj.readNestedProperty(obj, path));
        }
        return r;
    }
    /**
     * Extend given data
     * @param params parameters
     */
    static extend(params) {
        var _a, _b;
        let data = {};
        let keyRealPrefix = (_a = params.keyPrefix) !== null && _a !== void 0 ? _a : "";
        let keyRealSuffix = (_b = params.keySuffix) !== null && _b !== void 0 ? _b : "";
        for (const key in params.data) {
            if (params.omits && params.omits.find((k) => k === key)) {
                continue;
            }
            if (Object.hasOwnProperty.bind(params.data)(key)) {
                let value = params.data[key];
                /**
                 * Apply filter
                 */
                if (params.filters) {
                    const filterKey = Object.keys(params.filters).find((item) => item === key);
                    if (filterKey) {
                        let filterList = params.filters[filterKey];
                        if (!Array.isArray(filterList)) {
                            filterList = [filterList];
                        }
                        for (const filter of filterList) {
                            value = filter(value);
                        }
                    }
                }
                if (value !== null || value !== undefined) {
                    // inject value
                    data[`${keyRealPrefix}${key}${keyRealSuffix}`] = value;
                }
            }
        }
        /**
         * Inject additional data
         */
        if (params.additional) {
            data = Object.assign(Object.assign({}, data), params.additional);
        }
        return data;
    }
    /**
     * Reverse a flattened object
     * @param params parameters
     */
    static reverseFlatten(params) {
        var _a, _b;
        const separator = (_a = params.separator) !== null && _a !== void 0 ? _a : ".";
        const result = {};
        const flattenedData = (_b = params.flattened) !== null && _b !== void 0 ? _b : {};
        for (const key in flattenedData) {
            if (Object.hasOwnProperty.bind(flattenedData)(key) &&
                (!params.omits || !params.omits.includes(key))) {
                // initialize original key
                let originalKey = key;
                // remove suffix if exist
                if (params.suffix) {
                    originalKey = originalKey.substring(0, key.length - params.suffix.length + 1);
                }
                // remove preffix if exist
                if (params.prefix) {
                    originalKey = originalKey.substring(params.prefix.length, originalKey.length - 1);
                }
                if (!params.omits || !params.omits.includes(originalKey)) {
                    Obj.assignNestedProperty(result, originalKey.split(separator), flattenedData[key]);
                }
            }
        }
        return result;
    }
    /**
     * check if a value is an Object
     * @param data object
     */
    static isObject(data) {
        const r = data != null &&
            data != undefined &&
            !Array.isArray(data) &&
            typeof data === "object" &&
            (data === null || data === void 0 ? void 0 : data.constructor) === Object;
        return r;
    }
    /**
     * Merge two objects
     * @param left left object
     * @param right right object
     * @param priority left or right
     */
    static merge(left, right, priority = "left") {
        const mergedKeys = [];
        const leftData = left !== null && left !== void 0 ? left : {}, rightData = right !== null && right !== void 0 ? right : {};
        for (const key of [...Object.keys(leftData), ...Object.keys(rightData)]) {
            if (!mergedKeys.includes(key)) {
                mergedKeys.push(key);
            }
        }
        const merged = {};
        for (const key of mergedKeys) {
            switch (priority) {
                case "left":
                    merged[key] = firstValueOrNull(leftData[key], rightData[key]);
                    break;
                case "right":
                    merged[key] = firstValueOrNull(rightData[key], leftData[key]);
                    break;
            }
        }
        return merged;
    }
    /**
     * Merge two objects; it replace as soon as the key exists in the priority object
     * @param left left object
     * @param right right object
     * @param priority left or right
     */
    static mergeStrict(left, right, priority = "left") {
        const mergedKeys = [];
        const leftData = left !== null && left !== void 0 ? left : {}, rightData = right !== null && right !== void 0 ? right : {};
        for (const key of [...Object.keys(leftData), ...Object.keys(rightData)]) {
            if (!mergedKeys.includes(key)) {
                mergedKeys.push(key);
            }
        }
        const merged = {};
        for (const key of mergedKeys) {
            switch (priority) {
                case "left":
                    merged[key] = Object.prototype.hasOwnProperty.call(leftData, key)
                        ? leftData[key]
                        : rightData[key];
                    break;
                case "right":
                    merged[key] = Object.prototype.hasOwnProperty.call(rightData, key)
                        ? rightData[key]
                        : leftData[key];
                    break;
            }
        }
        return merged;
    }
    /**
     * Merge object with nested properties
     * @param params parameters
     */
    static mergeNested(params) {
        var _a, _b, _c, _d;
        const priority = (_a = params.priority) !== null && _a !== void 0 ? _a : "left";
        const separator = (_b = params.separator) !== null && _b !== void 0 ? _b : "----";
        const mergedKeys = {};
        const leftFlattened = Obj.flatten({ data: (_c = params.left) !== null && _c !== void 0 ? _c : {}, separator });
        const rightFlattened = Obj.flatten({ data: (_d = params.right) !== null && _d !== void 0 ? _d : {}, separator });
        for (const key of [
            ...Object.keys(leftFlattened),
            ...Object.keys(rightFlattened),
        ]) {
            if (!mergedKeys[key]) {
                mergedKeys[key] = true;
            }
        }
        const merged = {};
        for (const key of Object.keys(mergedKeys)) {
            switch (priority) {
                case "left":
                    merged[key] = firstValueOrNull(leftFlattened[key], rightFlattened[key]);
                    break;
                case "right":
                    merged[key] = firstValueOrNull(rightFlattened[key], leftFlattened[key]);
                    break;
            }
        }
        return Obj.reverseFlatten({
            flattened: merged,
            separator,
        });
    }
    /**
     * Merge object with nested properties; the target replace as soon as the key exists in the priority object
     * @param params parameters
     */
    static mergeNestedStrict(params) {
        var _a, _b, _c, _d;
        const priority = (_a = params.priority) !== null && _a !== void 0 ? _a : "left";
        const separator = (_b = params.separator) !== null && _b !== void 0 ? _b : "----";
        const mergedKeys = [];
        const leftFlattened = Obj.flatten({ data: (_c = params.left) !== null && _c !== void 0 ? _c : {}, separator });
        const rightFlattened = Obj.flatten({ data: (_d = params.right) !== null && _d !== void 0 ? _d : {}, separator });
        for (const key of [
            ...Object.keys(leftFlattened),
            ...Object.keys(rightFlattened),
        ]) {
            if (!mergedKeys.includes(key)) {
                mergedKeys.push(key);
            }
        }
        const merged = {};
        for (const key of mergedKeys) {
            switch (priority) {
                case "left":
                    merged[key] = Object.prototype.hasOwnProperty.call(leftFlattened, key)
                        ? leftFlattened[key]
                        : rightFlattened[key];
                    break;
                case "right":
                    merged[key] = Object.prototype.hasOwnProperty.call(rightFlattened, key)
                        ? rightFlattened[key]
                        : leftFlattened[key];
                    break;
            }
        }
        return Obj.reverseFlatten({
            flattened: merged,
            separator,
        });
    }
    /**
     * Remove null or undefined properties in an object
     * @param obj object to clean
     * @param separator separator for nested properties
     */
    static clean(obj, separator = ":-:-:") {
        const r = {};
        const flattened = Obj.flatten({ data: obj, separator: separator });
        for (const key in flattened) {
            if (Object.prototype.hasOwnProperty.call(flattened, key)) {
                const element = flattened[key];
                if (element !== null && element !== undefined) {
                    Obj.assignNestedProperty(r, key.split(separator), element);
                }
            }
        }
        return r;
    }
    /**
     * Remove null or undefined properties in an object
     * @param obj object to clean
     * @param separator separator for nested properties
     */
    static cleanWithEmpty(obj, separator = ":-:-:") {
        const r = {};
        const flattened = Obj.flatten({ data: obj, separator: separator });
        // console.log("flattened", flattened);
        for (const key in flattened) {
            if (Object.prototype.hasOwnProperty.call(flattened, key)) {
                const element = flattened[key];
                if ((element !== null &&
                    element !== undefined &&
                    typeof element !== "string") ||
                    (typeof element === "string" && element.length !== 0)) {
                    Obj.assignNestedProperty(r, key.split(separator), element);
                }
            }
        }
        return r;
    }
    /**
     * Remove null, undefined, false, empty string and empty array properties in an object
     * @param obj object to clean
     * @param separator separator for nested properties
     */
    static cleanAll(obj, separator = ":-:-:") {
        const r = {};
        const flattened = Obj.flatten({ data: obj, separator: separator });
        // console.log("flattened", flattened);
        for (const key in flattened) {
            if (Object.prototype.hasOwnProperty.call(flattened, key)) {
                const element = flattened[key];
                if (element !== null &&
                    element !== undefined &&
                    (typeof element !== "string" || element.length !== 0) &&
                    (typeof element !== "boolean" || element === true) &&
                    (!Array.isArray(element) || element.length !== 0) &&
                    (typeof element !== "object" || Object.keys(element).length !== 0)) {
                    Obj.assignNestedProperty(r, key.split(separator), element);
                }
            }
        }
        return r;
    }
    /**
     * Turn undefined to null properties in an object
     * @param obj object to clean
     * @param separator separator for nested properties
     */
    static undefinedToNull(obj, separator = ":-:-:") {
        const r = {};
        const flattened = Obj.flatten({ data: obj, separator: separator });
        // console.log("flattened", flattened);
        for (const key in flattened) {
            if (Object.prototype.hasOwnProperty.call(flattened, key)) {
                const element = flattened[key];
                if (element === undefined) {
                    Obj.assignNestedProperty(r, key.split(separator), null);
                }
                else {
                    Obj.assignNestedProperty(r, key.split(separator), element);
                }
            }
        }
        return r;
    }
}
/**
 * Flatten an object
 * @param params parameters
 */
Obj.flatten = (params) => {
    var _a, _b, _c, _d;
    let separator = (_a = params.separator) !== null && _a !== void 0 ? _a : ".";
    let realPrefix = (_b = params.prefix) !== null && _b !== void 0 ? _b : "";
    let realSuffix = (_c = params.suffix) !== null && _c !== void 0 ? _c : "";
    let result = {};
    let data = (_d = params.data) !== null && _d !== void 0 ? _d : {};
    for (const key in data) {
        if (Object.hasOwnProperty.bind(data)(key)) {
            const element = (data)[key];
            if (Obj.isObject(element)) {
                if (Object.keys(element).length !== 0) {
                    result = Object.assign(Object.assign({}, result), Obj.flatten({
                        data: element,
                        prefix: `${realPrefix}${key}${separator}`,
                        suffix: realSuffix,
                        separator: separator,
                    }));
                }
                else {
                    result[`${realPrefix}${key}`] = element;
                }
            }
            else {
                const newKey = `${realPrefix}${key}${realSuffix}`;
                if (!params.omits ||
                    !params.omits.find((item) => `${realPrefix}${item}${realSuffix}` === newKey)) {
                    result[`${realPrefix}${key}${realSuffix}`] = element;
                }
            }
        }
    }
    return result;
};
exports.default = Obj;
